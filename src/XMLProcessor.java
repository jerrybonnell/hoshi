package src;

import java.util.*;
import java.io.*;

/**
 * process an XML file
 *
 * date last modified: 8 jan 2019
 * last modified by: jerry bonnell
 * 
 * notes: replace trim() with tempTrim() because of situation where 
 * a tag like <said who=""> ends up as <saidwho> due to excessive trimming
 *
 */
public class XMLProcessor implements Iterable<Block>
{

  /* **************************************************************
   * The program works by reading line after line from the scanner
   *
   * . The line that is being read is stored in buffer
   * . currentLine is the line position of the last line added to the
   * . currentPosition is the scan position in the buffer line
   * ************************************************************ */
  private BufferedReader reader;
  private String buffer;
  private int currentLine;
  private int currentPosition;
  private String tagString;
  private int fromLine;
  private int fromPosition;
  private int toLine;
  private int toPosition;

  /**
   * constructor
   * @param s	BufferedReader
   */
  public XMLProcessor( BufferedReader r ) throws IOException
  {
    reader = r;
    buffer = r.readLine(); 
    buffer = fullTrim( buffer );
    currentPosition = 0;
    currentLine = 1;
    tagString = "";
  }
  /**
   * constructor
   * @param f	File
   */
  public XMLProcessor( File f ) throws IOException
  {
    this( new BufferedReader( new InputStreamReader(
        new FileInputStream( f ), "UTF-8") ) );
  }
  /**
   * @return the tag string of the current token
   */
  public String getTagString()
  {
    return tagString;
  }
  /**
   * @return the string generated by trimming most of the spaces
   */
  public String tempTrim( String w )
  {
    return ( w == null ) ? null : " " + w.trim();
  }
  /**
   * @return the string generated by trimming
   */
  public String fullTrim( String w )
  {

    return ( w == null ) ? null : w.trim();
  }
  /**
   * @return the string generated by removing its trailing space
   */
  public String tailTrim( String w )
  {
    if ( w == null )
    {
      return null;
    }
    int len = w.length() - 1;
    while ( len >= 0 &&
        ( w.charAt( len ) == ' ' || w.charAt( len ) == '\t' ) )
    {
      len --;
    }
    return w.substring( 0, len + 1 );
  }
  /**
   * find the start of the next token
   * @return whether the search has been successful
   */
  private boolean locateStart() throws IOException
  {
    /*
     * if there is still a character in the buffer
     * simply return true
     *
     * otherwise, keep reading from the scanner and update
     * the line position until a non-empty line appears,
     * then return true
     *
     * if failed, return false
     */
    /// System.out.println( "locate " + currentPosition + ":" + buffer );
    if ( currentPosition < buffer.length() )
    {
      return true;
    }
    currentPosition = 0;
    while ( ( buffer = reader.readLine() ) != null )
    {
      buffer = fullTrim( buffer );
      currentLine ++;
      if (buffer.length() > 0)
      {
        return true;
      }
    }
    return false;
  }
  /**
   * extract token in the case the current position in the
   * buffer is a "<"
   */
  private void getTagOld() throws IOException
  {
    // System.out.println( "getTag " + currentPosition + " " + buffer );
    // set the value of fromPosition as well as that of fromLine
    fromLine = currentLine;
    fromPosition = currentPosition;
    /*
     * set p to the position of '>' in the buffer after currentPosition
     *
     * if p is position set the value of toLine and toPosition
     * extract the toekn into tagString and update currentPosition
     */
    int p = buffer.indexOf( ">", currentPosition );
    if ( p >= 0 )
    {
      toLine = currentLine;
      toPosition = p + 1;
      tagString = buffer.substring( fromPosition, toPosition );
      currentPosition = toPosition;
    }
    /*
     * otherwise, initialize tagString with the remainder of buffer
     * and then keep adding to tagString the next lines
     * until a '>' is found, and then
     * the value of toLine and toPosition
     * extract the token into tagString and update currentPosition
     */
    else
    {
      tagString = buffer.substring(fromPosition);
      boolean found = false;
      while ( ( buffer = reader.readLine() ) != null )
      {
        buffer = fullTrim( buffer );
        currentLine ++;
        p = buffer.indexOf( ">" );
        found = ( p >= 0 );
        if ( found )
        {
          toPosition = p + 1;
          tagString += buffer.substring( 0, toPosition );
          currentPosition = toPosition;
          break;
        }
        else
        {
          tagString += buffer;
        }
      }
      if ( !found )
      {
        System.out.println( "not found line = " + currentLine );
        tagString = null;
      }
    }
  }
  /**
   * extract token in the case the current position in the
   * buffer is a "<"
   */
  private void getTag() throws IOException
  {
    int excess = +1;
    fromLine = currentLine;
    fromPosition = currentPosition;
    tagString = buffer.substring( fromPosition, fromPosition + 1 );
    currentPosition ++;

    while ( excess > 0 )
    {
      if ( currentPosition == buffer.length() )
      {
        buffer = reader.readLine();
        buffer = tempTrim(buffer);
        currentLine ++;
        if ( buffer == null )
        {
          throw new IOException( "TAG Incomplete = " + tagString );
        }
        currentPosition = 0;
      }
      while ( currentPosition < buffer.length() )
      {
        char c = buffer.charAt( currentPosition );
        char d = ( currentPosition > 0 ) ?
            buffer.charAt( currentPosition - 1 ) : ' ';
        currentPosition ++;
        tagString += c;
        if ( c == '>' && d != '^' )
        {
          excess --;
          if ( excess == 0 )
          {
            break;
          }
        }
        else if ( c == '<' && d != '^' )
        {
          excess ++;
        }
      }
    }
    toLine = currentLine;
    toPosition = currentPosition;
  }  
  /**
   * extract token in the case the current position in the
   * buffer is a "&"
   */
  private void getHtmTag()
  {
    int p = buffer.indexOf( ";", currentPosition );
    if ( p < 0 )
    {
      System.out.println( "html tag error" );
    }
    /*
     * extract the substring between the currentPosition and p
     * into tagString, and then
     * update the token location variables
     * as well as update currentPosition
     */
    tagString = buffer.substring( currentPosition, p );
    fromLine = currentLine;
    fromPosition = currentPosition;
    toLine = currentLine;
    toPosition = p;
    currentPosition = p;
  }

  /**
   * extract token in the case the current position in the
   * buffer is NOT a "<"
   */
  private void getNonTag()
  {
    /*
     * set p to the position of '<' or '&'
     * in the buffer after currentPosition
     * if p is negative set the value of p to the length of buffer
     */
    int p = 0;
    int q = buffer.indexOf( "<", currentPosition );
    int r = buffer.indexOf( "&", currentPosition );
    p = ( q < 0 ) ? r : ( ( r < 0 ) ? q : Math.min( q, r ) );
    if ( p < 0 )
    {
      p = buffer.length();
    }
    /*
     * extract the substring between the currentPosition and p
     * into tagString, and then
     * update the token location variables
     * as well as update currentPosition
     */
    tagString = buffer.substring( currentPosition, p );
    fromLine = currentLine;
    fromPosition = currentPosition;
    toLine = currentLine;
    toPosition = p;
    currentPosition = p;
  }

  /**
   * process the next token
   */
  public void advance() throws IOException
  {
    ///// System.out.println( "adv. start " + currentPosition + buffer );
    /* if the start cannot be located return null
     * otherwise, depending on the character at currentPosition
     * choose between the two token extraction methods
     */
    if (!locateStart())
    {
      tagString = null;
    }
    else if (buffer.charAt(currentPosition) == '<')
    {
      getTag();
    }
    else if (buffer.charAt(currentPosition) == '&')
    {
      getHtmTag();
    }
    else
    {
      getNonTag();
    }
    //// System.out.println( "adv. end " + currentPosition + buffer );
  }
  /**
   * obtain the next tagString
   * @return the next tagString
   */
  public String nextString() throws IOException
  {
    ///// System.out.println( "calling advance" );
    advance();
    return getTagString();
  }
  @Override
  public Iterator< Block > iterator()
  {
    Iterator< Block > obj;
    try
    {
      obj = new BlockIterator();
    }
    catch ( IOException e )
    {
      obj = null;
      System.out.println( "Iterator< Block > error" );
    }
    return obj;
  }
  /**
   * an internal class for implementing Iterator
   */
  public class BlockIterator implements Iterator< Block >
  {
    String current;
    public BlockIterator() throws IOException
    {
    /*
     * read the next token and set it to current,
     * this is performed at the time of construction
     */
      current = nextString();
    }
    /*
     * methods required by interface Iterator
     */
    @Override
    public boolean hasNext()
    {
      return current != null;
    }
    @Override
    public Block next() throws NullPointerException
    {
      /*
       * if current is null, then throw an exception, since no token
       * is remaining,
       * otherwise, create a new Block object using the current string
       * update current,
       * return the object created
       */
      if (current == null)
      {
        throw new NullPointerException( "File end has been reached" );
      }
      Block b = new Block( current, fromLine, fromPosition,
          toLine, toPosition );
      try
      {
        current = nextString();
      }
      catch ( IOException e )
      {
        throw new NullPointerException( "Error occurred while reading." );
      }
      return b;
    }
  }

}

